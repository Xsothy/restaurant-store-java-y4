<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <th:block th:replace="~{fragments/layout :: head('My Orders - Restaurant Store')}"></th:block>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Kantumruy+Pro:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Kantumruy Pro', sans-serif;
        }
        [x-cloak] { display: none !important; }
        .status-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem 1rem;
            border-radius: 9999px;
            font-size: 0.875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .status-PENDING { background-color: #fef3c7; color: #92400e; }
        .status-CONFIRMED { background-color: #dbeafe; color: #1e40af; }
        .status-PREPARING { background-color: #ede9fe; color: #5b21b6; }
        .status-READY_FOR_PICKUP { background-color: #ecfccb; color: #3f6212; }
        .status-READY_FOR_DELIVERY { background-color: #e0e7ff; color: #3730a3; }
        .status-OUT_FOR_DELIVERY { background-color: #cffafe; color: #0f766e; }
        .status-COMPLETED { background-color: #dcfce7; color: #166534; }
        .status-CANCELLED { background-color: #fee2e2; color: #991b1b; }
        .status-DELIVERED { background-color: #dcfce7; color: #166534; }
        .payment-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.35rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .payment-PENDING { background-color: #fef3c7; color: #92400e; }
        .payment-AWAITING_SESSION { background-color: #fef3c7; color: #92400e; }
        .payment-AWAITING_WEBHOOK { background-color: #e0f2fe; color: #075985; }
        .payment-CASH_PENDING { background-color: #fff7ed; color: #9a3412; }
        .payment-PROCESSING { background-color: #e0f2fe; color: #1e40af; }
        .payment-COMPLETED { background-color: #dcfce7; color: #166534; }
        .payment-FAILED { background-color: #fee2e2; color: #991b1b; }
        .payment-CANCELLED { background-color: #f1f5f9; color: #475569; }
        .payment-REFUNDED { background-color: #ede9fe; color: #5b21b6; }
    </style>
</head>
<body class="bg-gradient-to-br from-gray-50 to-gray-100 min-h-screen">
    <th:block th:replace="~{fragments/layout :: header}"></th:block>

    <main class="max-w-7xl mx-auto px-4 sm:px-6 py-8" x-data="ordersPage()" x-init="init()" x-cloak>
        <div class="mb-8">
            <h1 class="text-3xl font-bold text-gray-800">My Orders</h1>
            <p class="text-gray-600 mt-2">Track and manage your orders</p>
        </div>

        <div th:if="${successMessage}" class="mb-6 rounded-lg border border-green-200 bg-green-50 px-4 py-3 text-green-700">
            <span th:text="${successMessage}"></span>
        </div>
        <div th:if="${errorMessage}" class="mb-6 rounded-lg border border-red-200 bg-red-50 px-4 py-3 text-red-700">
            <span th:text="${errorMessage}"></span>
        </div>

        <div x-show="runtimeError" x-cloak class="mb-6 rounded-lg border border-amber-200 bg-amber-50 px-4 py-3 text-amber-700" x-text="runtimeError"></div>

        <div x-show="!ready" x-cloak class="text-center py-16 text-gray-500">
            <p class="text-lg font-medium">Loading your latest orders...</p>
            <p class="text-sm">One moment while we prepare your dashboard.</p>
        </div>

        <div x-show="ready && orders.length === 0" x-cloak class="text-center py-20">
            <svg class="w-24 h-24 mx-auto text-gray-300 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
            </svg>
            <p class="text-gray-500 text-lg mb-6">No orders yet</p>
            <button onclick="window.location.href='/menu'" class="px-6 py-3 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors">
                Start Shopping
            </button>
        </div>

        <div x-show="ready && orders.length > 0" x-cloak class="space-y-6">
            <template x-for="order in orders" :key="order.id">
                <div class="bg-white rounded-xl shadow-md p-6">
                    <div class="flex flex-col md:flex-row md:items-center justify-between mb-4 pb-4 border-b">
                        <div>
                            <h3 class="text-xl font-bold text-gray-800 mb-1">
                                Order #<span x-text="order.id"></span>
                            </h3>
                            <p class="text-sm text-gray-500" x-text="formatEnum(order.orderType)"></p>
                            <p class="text-sm text-gray-500" x-text="formatDateTime(order.createdAt)"></p>
                        </div>
                        <div class="mt-3 md:mt-0 flex flex-col md:flex-row md:items-center gap-4 text-right md:text-left">
                            <span class="status-badge" :class="statusBadgeClass(order.status)" x-text="formatEnum(order.status)"></span>
                            <span class="text-2xl font-bold text-red-600" x-text="formatCurrency(order.totalPrice)"></span>
                        </div>
                    </div>

                    <details class="mt-4 group">
                        <summary class="text-sm text-gray-600 cursor-pointer select-none flex items-center justify-between">
                            <span>View items and delivery details</span>
                            <span class="text-xs text-gray-400 group-open:hidden">Click to expand</span>
                            <span class="text-xs text-gray-400 hidden group-open:inline">Click to collapse</span>
                        </summary>
                        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mt-3">
                            <div class="lg:col-span-2 space-y-3">
                                <template x-for="item in orderItemsList(order)" :key="item.id || `${order.id}-${item.productId || item.productName}`">
                                    <div class="flex items-center gap-4 py-2">
                                        <img :src="item.productImageUrl || placeholderImage"
                                             :alt="item.productName"
                                             class="w-16 h-16 object-cover rounded-lg"
                                             @error.once="$event.target.src = placeholderImage">
                                        <div class="flex-1">
                                            <h4 class="font-semibold text-gray-800" x-text="item.productName"></h4>
                                            <p class="text-sm text-gray-500">
                                                <span x-text="item.quantity"></span>
                                                ×
                                                <span x-text="formatCurrency(item.unitPrice)"></span>
                                            </p>
                                        </div>
                                        <div class="text-right">
                                            <p class="font-semibold text-gray-800" x-text="formatCurrency(item.totalPrice)"></p>
                                        </div>
                                    </div>
                                </template>
                            </div>

                            <div class="space-y-4">
                                <div class="bg-gray-50 rounded-lg p-4">
                                    <h4 class="font-semibold text-gray-800 mb-2">Payment</h4>
                                    <p class="text-sm text-gray-600">
                                        Method:
                                        <span class="font-medium" x-text="paymentMethodLabel(order)"></span>
                                    </p>
                                    <p class="text-sm text-gray-600">
                                        Status:
                                        <span class="payment-badge" :class="paymentStatusClass(order.paymentStatus)" x-text="paymentStatusLabel(order.paymentStatus)"></span>
                                    </p>
                                </div>

                                <div class="bg-green-50 rounded-lg p-4" x-show="order.orderType === 'PICKUP'" x-cloak>
                                    <h4 class="font-semibold text-gray-800 mb-2">Pickup</h4>
                                    <p class="text-sm text-gray-600">
                                        Status:
                                        <span class="font-medium" x-text="pickupStatusLabel(order)"></span>
                                    </p>
                                    <p class="text-sm text-gray-600">
                                        Ready at:
                                        <span class="font-medium" x-text="pickupReadyLabel(order)"></span>
                                    </p>
                                    <p class="text-sm text-gray-600">
                                        Pickup window:
                                        <span class="font-medium" x-text="pickupWindowLabel(order)"></span>
                                    </p>
                                    <p class="text-sm text-gray-600" x-show="order.pickupPickedUpAt">
                                        Picked up:
                                        <span class="font-medium" x-text="pickupPickedUpLabel(order)"></span>
                                    </p>
                                    <p class="text-sm text-gray-600" x-show="order.pickupCode">
                                        Pickup code:
                                        <span class="font-mono text-sm" x-text="pickupCodeLabel(order)"></span>
                                    </p>
                                    <p class="text-sm text-gray-600">
                                        Instructions:
                                        <span class="font-medium" x-text="pickupInstructionsLabel(order)"></span>
                                    </p>
                                </div>

                                <div class="bg-blue-50 rounded-lg p-4" x-show="order.orderType === 'DELIVERY'">
                                    <h4 class="font-semibold text-gray-800 mb-2">Delivery</h4>
                                    <p class="text-sm text-gray-600">
                                        Status:
                                        <span class="font-medium" x-text="deliveryStatusLabel(order.deliveryStatus)"></span>
                                    </p>
                                    <p class="text-sm text-gray-600">
                                        Driver:
                                        <span class="font-medium" x-text="driverNameLabel(order)"></span>
                                        <span class="text-gray-400" x-text="driverPhoneLabel(order)"></span>
                                    </p>
                                    <p class="text-sm text-gray-600" x-show="order.deliveryEstimatedArrivalTime">
                                        ETA:
                                        <span class="font-medium" x-text="formatDateTime(order.deliveryEstimatedArrivalTime)"></span>
                                    </p>
                                </div>

                                <a :href="`/orders/${order.id}`"
                                   class="inline-flex items-center justify-center w-full px-4 py-2 border border-gray-300 rounded-lg text-sm font-medium text-gray-700 hover:bg-gray-100 transition-colors">
                                    View Details
                                </a>
                            </div>
                        </div>
                    </details>
                </div>
            </template>
        </div>
    </main>

    <th:block th:replace="~{fragments/layout :: footer}"></th:block>
    <th:block th:replace="~{fragments/layout :: api-config}"></th:block>
    <th:block th:replace="~{fragments/layout :: auth-utils}"></th:block>

    <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>
    <script th:inline="javascript">
        window.INITIAL_ORDERS = /*[[${orders}]]*/ [];
        if (!Array.isArray(window.INITIAL_ORDERS)) {
            window.INITIAL_ORDERS = window.INITIAL_ORDERS ? [window.INITIAL_ORDERS] : [];
        }
    </script>
    <script>
        const ORDER_STATUS_CLASS_MAP = {
            'PENDING': 'status-PENDING',
            'CONFIRMED': 'status-CONFIRMED',
            'PREPARING': 'status-PREPARING',
            'READY_FOR_PICKUP': 'status-READY_FOR_PICKUP',
            'READY_FOR_DELIVERY': 'status-READY_FOR_DELIVERY',
            'OUT_FOR_DELIVERY': 'status-OUT_FOR_DELIVERY',
            'COMPLETED': 'status-COMPLETED',
            'CANCELLED': 'status-CANCELLED',
            'DELIVERED': 'status-DELIVERED'
        };

        const PAYMENT_STATUS_CLASS_MAP = {
            'PENDING': 'payment-PENDING',
            'AWAITING_SESSION': 'payment-AWAITING_SESSION',
            'AWAITING_WEBHOOK': 'payment-AWAITING_WEBHOOK',
            'CASH_PENDING': 'payment-CASH_PENDING',
            'PROCESSING': 'payment-PROCESSING',
            'COMPLETED': 'payment-COMPLETED',
            'FAILED': 'payment-FAILED',
            'CANCELLED': 'payment-CANCELLED',
            'REFUNDED': 'payment-REFUNDED'
        };

        function ordersPage() {
            return {
                orders: [],
                ready: false,
                runtimeError: '',
                stompClient: null,
                pollTimerId: null,
                subscriptions: new Map(),
                placeholderImage: 'https://images.unsplash.com/photo-1546069901-ba9599a7e63c?auto=format&fit=crop&w=100&q=80',

                init() {
                    this.orders = this.normalizeOrders(window.INITIAL_ORDERS || []);
                    this.ready = true;
                    this.connectWebsocket();
                    this.startPolling();
                    window.addEventListener('beforeunload', () => this.teardown());
                },

                normalizeOrders(list) {
                    if (!Array.isArray(list)) {
                        return [];
                    }
                    return list
                        .filter(Boolean)
                        .map(order => this.prepareOrder(order));
                },

                prepareOrder(order) {
                    if (!order) {
                        return null;
                    }
                    const normalized = {
                        ...order
                    };
                    normalized.orderItems = Array.isArray(order.orderItems) ? order.orderItems : [];
                    if (!normalized.paymentMethod && normalized.paymentStatus === 'CASH_PENDING') {
                        normalized.paymentMethod = 'CASH_ON_DELIVERY';
                    }
                    return normalized;
                },

                connectWebsocket() {
                    if (typeof SockJS === 'undefined' || typeof Stomp === 'undefined') {
                        return;
                    }
                    const socket = new SockJS('/ws');
                    this.stompClient = Stomp.over(socket);
                    this.stompClient.reconnect_delay = 5000;
                    this.stompClient.connect({}, () => {
                        this.orders.forEach(order => this.subscribeToOrder(order.id));
                    }, error => {
                        console.warn('Unable to connect to order updates', error);
                    });
                },

                subscribeToOrder(orderId) {
                    if (!orderId || !this.stompClient || !this.stompClient.connected || this.subscriptions.has(orderId)) {
                        return;
                    }
                    const subs = [];
                    subs.push(this.stompClient.subscribe(`/topic/orders/${orderId}`, message => {
                        this.handleIncomingUpdate(orderId, message);
                    }));
                    const handleStatusPayload = message => {
                        try {
                            const payload = JSON.parse(message.body);
                            this.applyOrderStatusPayload(orderId, payload);
                        } catch (error) {
                            console.error('Failed to parse order status update', error);
                        }
                    };
                    subs.push(this.stompClient.subscribe(`/topic/orders/${orderId}/status`, handleStatusPayload));
                    subs.push(this.stompClient.subscribe(`/topic/orders/${orderId}/notifications`, handleStatusPayload));
                    this.subscriptions.set(orderId, subs);
                },

                handleIncomingUpdate(orderId, message) {
                    try {
                        const payload = JSON.parse(message.body);
                        if (!payload.id) {
                            payload.id = orderId;
                        }
                        this.applyOrderUpdate(payload);
                    } catch (error) {
                        console.error('Failed to parse order update', error);
                    }
                },

                resubscribeActiveOrders() {
                    if (!this.stompClient || !this.stompClient.connected) {
                        return;
                    }
                    const activeIds = new Set(this.orders.map(order => order.id));
                    activeIds.forEach(id => this.subscribeToOrder(id));
                    this.subscriptions.forEach((subs, id) => {
                        if (!activeIds.has(id)) {
                            subs.forEach(sub => sub.unsubscribe());
                            this.subscriptions.delete(id);
                        }
                    });
                },

                startPolling() {
                    if (this.pollTimerId) {
                        clearInterval(this.pollTimerId);
                    }
                    this.pollTimerId = window.setInterval(() => this.refreshOrders(), 30000);
                },

                async refreshOrders() {
                    if (!window.API_BASE_URL) {
                        return;
                    }
                    const token = localStorage.getItem('token');
                    if (!token) {
                        this.runtimeError = 'Please login to view your orders.';
                        return;
                    }
                    try {
                        const response = await fetch(`${API_BASE_URL}/orders/my-orders`, {
                            headers: {
                                'Authorization': `Bearer ${token}`
                            }
                        });
                        if (response.status === 401) {
                            window.location.href = LOGIN_PAGE_URL;
                            return;
                        }
                        const payload = await response.json();
                        if (!payload.success || !Array.isArray(payload.data)) {
                            throw new Error(payload.message || 'Unable to load orders right now.');
                        }
                        this.orders = this.normalizeOrders(payload.data);
                        this.ready = true;
                        this.runtimeError = '';
                        this.resubscribeActiveOrders();
                    } catch (error) {
                        console.error('Failed to refresh orders', error);
                        this.runtimeError = error.message || 'Unable to refresh your orders right now.';
                    }
                },

                applyOrderUpdate(update) {
                    if (!update || !update.id) {
                        return;
                    }
                    const index = this.orders.findIndex(order => order.id === update.id);
                    const merged = this.prepareOrder({ ...(this.orders[index] || {}), ...update });
                    if (index === -1) {
                        this.orders = [...this.orders, merged];
                        if (this.stompClient?.connected) {
                            this.subscribeToOrder(update.id);
                        }
                    } else {
                        this.orders.splice(index, 1, merged);
                    }
                },

                applyOrderStatusPayload(orderId, payload) {
                    if (!payload) {
                        return;
                    }
                    const update = { id: orderId };
                    if (payload.status) {
                        update.status = payload.status;
                    }
                    if (payload.estimatedDeliveryTime) {
                        update.estimatedDeliveryTime = payload.estimatedDeliveryTime;
                    }
                    Object.assign(update, this.extractMetadataUpdates(payload.metadata));
                    this.applyOrderUpdate(update);
                },

                extractMetadataUpdates(metadata) {
                    if (!metadata || typeof metadata !== 'object') {
                        return {};
                    }
                    const updates = {};
                    const delivery = metadata.delivery || {};
                    const driver = delivery.driver || {};
                    const driverName = metadata.deliveryDriverName || metadata.driverName || driver.fullName || driver.name;
                    const driverPhone = metadata.deliveryDriverPhone || metadata.driverPhone || driver.phone || driver.email;
                    const driverStatus = metadata.deliveryStatus || metadata.driverStatus || delivery.status;
                    const eta = metadata.deliveryEstimatedArrivalTime || metadata.deliveryEta || metadata.estimatedArrivalTime || delivery.estimatedArrivalTime;
                    const actualDelivered = metadata.deliveryActualDeliveryTime || metadata.deliveredAt || delivery.deliveredAt || delivery.actualDeliveryTime;
                    const lat = metadata.deliveryLatitude ?? delivery.latitude;
                    const lng = metadata.deliveryLongitude ?? delivery.longitude;
                    const deliveryEta = delivery.estimatedDeliveryTime || delivery.estimatedArrivalTime;

                    if (driverName) {
                        updates.deliveryDriverName = driverName;
                    }
                    if (driverPhone) {
                        updates.deliveryDriverPhone = driverPhone;
                    }
                    if (driverStatus) {
                        updates.deliveryStatus = driverStatus;
                    }
                    if (eta || deliveryEta) {
                        updates.deliveryEstimatedArrivalTime = eta || deliveryEta;
                    }
                    if (actualDelivered) {
                        updates.deliveryActualDeliveryTime = actualDelivered;
                    }
                    if (lat) {
                        updates.deliveryLatitude = lat;
                    }
                    if (lng) {
                        updates.deliveryLongitude = lng;
                    }
                    if (metadata.paymentStatus) {
                        updates.paymentStatus = metadata.paymentStatus;
                    }
                    if (metadata.paymentMethod) {
                        updates.paymentMethod = metadata.paymentMethod;
                    }
                    if (metadata.pickupStatus) {
                        updates.pickupStatus = metadata.pickupStatus;
                    }
                    if (metadata.pickupCode) {
                        updates.pickupCode = metadata.pickupCode;
                    }
                    if (metadata.pickupWindowStart) {
                        updates.pickupWindowStart = metadata.pickupWindowStart;
                    }
                    if (metadata.pickupWindowEnd) {
                        updates.pickupWindowEnd = metadata.pickupWindowEnd;
                    }
                    if (metadata.pickupReadyAt) {
                        updates.pickupReadyAt = metadata.pickupReadyAt;
                    }
                    if (metadata.pickupPickedUpAt) {
                        updates.pickupPickedUpAt = metadata.pickupPickedUpAt;
                    }
                    if (metadata.pickupInstructions) {
                        updates.pickupInstructions = metadata.pickupInstructions;
                    }
                    if (metadata.status) {
                        updates.status = metadata.status;
                    }
                    if (metadata.orderStatus) {
                        updates.status = metadata.orderStatus;
                    }
                    return updates;
                },

                teardown() {
                    if (this.pollTimerId) {
                        clearInterval(this.pollTimerId);
                        this.pollTimerId = null;
                    }
                    this.subscriptions.forEach(subs => subs.forEach(sub => sub.unsubscribe()));
                    this.subscriptions.clear();
                    if (this.stompClient) {
                        try {
                            this.stompClient.disconnect();
                        } catch (error) {
                            console.warn('Error disconnecting socket', error);
                        }
                        this.stompClient = null;
                    }
                },

                orderItemsList(order) {
                    return Array.isArray(order?.orderItems) ? order.orderItems : [];
                },

                statusBadgeClass(status) {
                    return ORDER_STATUS_CLASS_MAP[status] || 'status-PENDING';
                },

                paymentStatusClass(status) {
                    return status ? (PAYMENT_STATUS_CLASS_MAP[status] || '') : '';
                },

                paymentMethodLabel(order) {
                    const method = order?.paymentMethod || (order?.paymentStatus === 'CASH_PENDING' ? 'CASH_ON_DELIVERY' : null);
                    return method ? this.formatEnum(method) : 'N/A';
                },

                paymentStatusLabel(status) {
                    return status ? this.formatEnum(status) : 'N/A';
                },

                deliveryStatusLabel(status) {
                    return status ? this.formatEnum(status) : 'Pending';
                },

                driverNameLabel(order) {
                    return order?.deliveryDriverName || 'Not assigned yet';
                },

                driverPhoneLabel(order) {
                    return order?.deliveryDriverPhone ? `(${order.deliveryDriverPhone})` : '';
                },

                pickupStatusLabel(order) {
                    const status = order?.pickupStatus;
                    return status ? this.formatEnum(status) : 'Awaiting confirmation';
                },

                pickupReadyLabel(order) {
                    return order?.pickupReadyAt ? this.formatDateTime(order.pickupReadyAt) : 'Not ready yet';
                },

                pickupWindowLabel(order) {
                    const start = order?.pickupWindowStart ? this.formatDateTime(order.pickupWindowStart) : null;
                    const end = order?.pickupWindowEnd ? this.formatDateTime(order.pickupWindowEnd) : null;
                    if (start && end) {
                        return `${start} → ${end}`;
                    }
                    return start || end || 'Pending';
                },

                pickupPickedUpLabel(order) {
                    return order?.pickupPickedUpAt ? this.formatDateTime(order.pickupPickedUpAt) : '';
                },

                pickupCodeLabel(order) {
                    return order?.pickupCode || 'Available when ready';
                },

                pickupInstructionsLabel(order) {
                    return order?.pickupInstructions || 'Follow staff guidance when you arrive.';
                },

                formatCurrency(value) {
                    const number = Number(value);
                    if (!Number.isNaN(number) && Number.isFinite(number)) {
                        return `${number.toLocaleString('en-US')}៛`;
                    }
                    return value ? `${value}៛` : '0៛';
                },

                formatDateTime(value) {
                    if (!value) {
                        return '';
                    }
                    try {
                        const date = new Date(value);
                        if (!Number.isNaN(date.getTime())) {
                            return date.toLocaleString('en-US', {
                                year: 'numeric',
                                month: 'short',
                                day: 'numeric',
                                hour: '2-digit',
                                minute: '2-digit'
                            });
                        }
                    } catch (error) {
                        console.warn('Unable to format date', value, error);
                    }
                    return value;
                },

                formatEnum(value) {
                    if (!value) {
                        return 'N/A';
                    }
                    return value
                        .toString()
                        .split('_')
                        .map(part => part.charAt(0) + part.slice(1).toLowerCase())
                        .join(' ');
                }
            };
        }
    </script>
</body>
</html>
