<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <th:block th:replace="~{fragments/layout :: head('Order Details - Restaurant Store')}"></th:block>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Kantumruy+Pro:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Kantumruy Pro', sans-serif;
            background: #f6f6f8;
        }
        [x-cloak] { display: none !important; }
        .card-shell {
            background: #ffffff;
            border-radius: 24px;
            border: 1px solid #f0f1f5;
            box-shadow: 0 20px 45px rgba(15, 23, 42, 0.06);
        }
        .section-label {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            font-weight: 600;
            color: #9ca3af;
        }
        .status-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.45rem 0.95rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .status-PENDING { background-color: #fef3c7; color: #92400e; }
        .status-CONFIRMED { background-color: #dbeafe; color: #1e40af; }
        .status-PREPARING { background-color: #ede9fe; color: #5b21b6; }
        .status-READY_FOR_PICKUP { background-color: #ecfccb; color: #3f6212; }
        .status-READY_FOR_DELIVERY { background-color: #e0e7ff; color: #3730a3; }
        .status-OUT_FOR_DELIVERY { background-color: #cffafe; color: #0f766e; }
        .status-COMPLETED { background-color: #dcfce7; color: #166534; }
        .status-CANCELLED { background-color: #fee2e2; color: #991b1b; }
        .status-DELIVERED { background-color: #dcfce7; color: #166534; }
        .payment-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.35rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .payment-PENDING { background-color: #fef3c7; color: #92400e; }
        .payment-AWAITING_SESSION { background-color: #fef3c7; color: #92400e; }
        .payment-AWAITING_WEBHOOK { background-color: #e0f2fe; color: #075985; }
        .payment-CASH_PENDING { background-color: #fff7ed; color: #9a3412; }
        .payment-PROCESSING { background-color: #e0f2fe; color: #1e40af; }
        .payment-COMPLETED { background-color: #dcfce7; color: #166534; }
        .payment-FAILED { background-color: #fee2e2; color: #991b1b; }
        .payment-CANCELLED { background-color: #f1f5f9; color: #475569; }
        .payment-REFUNDED { background-color: #ede9fe; color: #5b21b6; }
        .order-tracking-wrapper {
            position: relative;
        }
        .order-tracking-timeline {
            position: relative;
            padding-left: 2.5rem;
            margin-top: 1.5rem;
        }
        .order-tracking-timeline::before {
            content: '';
            position: absolute;
            left: 0.95rem;
            top: 0;
            bottom: 0;
            width: 2px;
            background: linear-gradient(180deg, rgba(226, 232, 240, 0.8), rgba(226, 232, 240, 0));
        }
        .tracking-step {
            position: relative;
            padding-left: 1.25rem;
            padding-bottom: 1.75rem;
        }
        .tracking-step:last-child {
            padding-bottom: 0;
        }
        .tracking-marker {
            position: absolute;
            left: -0.95rem;
            top: 0;
            width: 1.7rem;
            height: 1.7rem;
            border-radius: 9999px;
            border: 3px solid #dbeafe;
            background-color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.65rem;
            font-weight: 700;
            color: #1e40af;
            transition: all 0.3s ease;
        }
        .tracking-step-upcoming .tracking-marker {
            border-color: #e5e7eb;
            color: #94a3b8;
        }
        .tracking-step-completed .tracking-marker {
            border-color: #86efac;
            background-color: #86efac;
            color: #14532d;
            box-shadow: 0 10px 25px -12px rgba(34, 197, 94, 0.7);
        }
        .tracking-step-active .tracking-marker {
            border-color: #3b82f6;
            background-color: #2563eb;
            color: #ffffff;
            box-shadow: 0 10px 25px -12px rgba(37, 99, 235, 0.6);
        }
        .tracking-step-cancelled .tracking-marker {
            border-color: #fecaca;
            background-color: #fecaca;
            color: #991b1b;
            box-shadow: 0 10px 25px -15px rgba(185, 28, 28, 0.5);
        }
        @media (min-width: 768px) {
            .order-tracking-timeline {
                padding-left: 2.75rem;
            }
        }
        .order-tracking-wrapper {
            position: relative;
        }
        .order-tracking-timeline {
            position: relative;
            padding-left: 2.5rem;
            margin-top: 1.5rem;
        }
        .order-tracking-timeline::before {
            content: '';
            position: absolute;
            left: 0.95rem;
            top: 0;
            bottom: 0;
            width: 2px;
            background: linear-gradient(180deg, rgba(226, 232, 240, 0.8), rgba(226, 232, 240, 0));
        }
        .tracking-step {
            position: relative;
            padding-left: 1.25rem;
            padding-bottom: 1.75rem;
        }
        .tracking-step:last-child {
            padding-bottom: 0;
        }
        .tracking-marker {
            position: absolute;
            left: -0.95rem;
            top: 0;
            width: 1.7rem;
            height: 1.7rem;
            border-radius: 9999px;
            border: 3px solid #dbeafe;
            background-color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.65rem;
            font-weight: 700;
            color: #1e40af;
            transition: all 0.3s ease;
        }
        .tracking-step-upcoming .tracking-marker {
            border-color: #e5e7eb;
            color: #94a3b8;
        }
        .tracking-step-completed .tracking-marker {
            border-color: #86efac;
            background-color: #86efac;
            color: #14532d;
            box-shadow: 0 10px 25px -12px rgba(34, 197, 94, 0.7);
        }
        .tracking-step-active .tracking-marker {
            border-color: #3b82f6;
            background-color: #2563eb;
            color: #ffffff;
            box-shadow: 0 10px 25px -12px rgba(37, 99, 235, 0.6);
        }
        .tracking-step-cancelled .tracking-marker {
            border-color: #fecaca;
            background-color: #fecaca;
            color: #991b1b;
            box-shadow: 0 10px 25px -15px rgba(185, 28, 28, 0.5);
        }
        .tracking-connector {
            display: none;
        }
        @media (min-width: 768px) {
            .order-tracking-timeline {
                padding-left: 2.75rem;
            }
        }
        #deliveryMap {
            height: 400px;
            width: 100%;
            border-radius: 16px;
            border: 2px solid #e5e7eb;
        }
    </style>
</head>
<body class="min-h-screen">
    <th:block th:replace="~{fragments/layout :: header}"></th:block>

        <main class="max-w-3xl mx-auto px-4 sm:px-0 py-8" th:if="${order}" x-data="orderDetailsPage()" x-init="init()" x-cloak>
        <div class="mb-4 space-y-3">
            <div class="rounded-2xl border border-green-200 bg-green-50 px-4 py-3 text-green-700" th:text="${successMessage}"
                 th:if="${successMessage}"></div>
            <div class="rounded-2xl border border-red-200 bg-red-50 px-4 py-3 text-red-700" th:text="${errorMessage}"
                 th:if="${errorMessage}"></div>
            <div x-show="runtimeError" x-cloak class="rounded-2xl border border-amber-200 bg-amber-50 px-4 py-3 text-amber-700" x-text="runtimeError"></div>
        </div>

        <div x-show="!ready" x-cloak class="card-shell p-6 text-center text-gray-500">
            <p class="font-semibold mb-1">Loading your order...</p>
            <p class="text-sm">Please hold on while we fetch the latest details.</p>
        </div>

        <template x-if="ready && order">
            <div class="space-y-6">
                <div class="card-shell p-6">
                    <div class="flex items-start justify-between gap-6">
                        <div>
                            <p class="section-label">Order</p>
                            <h1 class="text-3xl font-semibold text-gray-900" x-text="orderTitle()"></h1>
                            <p class="text-sm text-gray-500 mt-1" x-text="placedOnLabel()"></p>
                        </div>
                        <div class="text-right">
                            <p class="section-label text-right">Total</p>
                            <p class="text-2xl font-bold text-gray-900" x-text="formatCurrency(order?.totalPrice)"></p>
                            <span class="status-badge mt-3 inline-flex" :class="statusBadgeClass(order?.status)" x-text="formatEnum(order?.status)"></span>
                        </div>
                    </div>
                    <div class="mt-5 grid grid-cols-1 sm:grid-cols-2 gap-4 text-sm text-gray-600">
                        <div>
                            <p class="text-gray-500">Order Type</p>
                            <p class="font-semibold text-gray-900" x-text="formatEnum(order?.orderType)"></p>
                        </div>
                        <div>
                            <p class="text-gray-500">Contact</p>
                            <p class="font-semibold text-gray-900" x-text="contactLabel()"></p>
                        </div>
                        <div x-show="order?.estimatedDeliveryTime">
                            <p class="text-gray-500">ETA</p>
                            <p class="font-semibold text-gray-900" x-text="formatDateTime(order.estimatedDeliveryTime)"></p>
                        </div>
                        <div x-show="order?.deliveryAddress">
                            <p class="text-gray-500">Address</p>
                            <p class="font-semibold text-gray-900" x-text="order.deliveryAddress"></p>
                        </div>
                    </div>
                </div>

                <div class="card-shell p-6 order-tracking-wrapper">
                    <div class="flex flex-col gap-3 md:flex-row md:items-start md:justify-between">
                        <div>
                            <p class="section-label">Order Progress</p>
                            <h2 class="text-xl font-semibold text-gray-900">Track your meal</h2>
                            <p class="text-sm text-gray-500" x-text="trackingHeroDescription()"></p>
                        </div>
                        <div class="text-sm text-gray-500 flex items-center gap-2" x-show="order?.updatedAt" x-cloak>
                            <svg class="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                            <span>Updated</span>
                            <span class="font-medium text-gray-700" x-text="formatDateTime(order.updatedAt)"></span>
                        </div>
                    </div>

                    <div class="bg-gray-50 rounded-2xl p-4 mt-4">
                        <div class="flex flex-col gap-4 md:flex-row md:items-center md:justify-between">
                            <div>
                                <p class="section-label">Progress</p>
                                <p class="text-2xl font-semibold text-gray-900" x-text="trackingProgressLabel()"></p>
                            </div>
                        </div>
                        <div class="relative mt-4 h-1.5 bg-white rounded-full overflow-hidden">
                            <div class="absolute inset-y-0 left-0 bg-gradient-to-r from-blue-400 via-blue-500 to-indigo-500 rounded-full transition-all duration-500"
                                 :style="`width: ${trackingProgressPercent()}%;`"></div>
                        </div>
<!--                        <p class="text-sm text-gray-600 mt-3" x-text="trackingRemainingLabel()"></p>-->
                    </div>

                    <div class="order-tracking-timeline">
                        <template x-for="(step, index) in currentTrackingSteps()" :key="`${step.code}-${index}`">
                            <div class="tracking-step" :class="trackingStepClass(step.code)">
                                <div class="tracking-marker" x-text="index + 1"></div>
                                <div class="tracking-connector" aria-hidden="true"></div>
                                <div class="space-y-1">
                                    <p class="text-xs uppercase tracking-wide text-gray-400" x-text="`Step ${index + 1} of ${trackingStepCount()}`"></p>
                                    <p class="font-semibold text-gray-800" x-text="step.label"></p>
                                    <p class="text-sm text-gray-500" x-text="step.description"></p>
                                </div>
                            </div>
                        </template>
                    </div>
                </div>

                <div class="grid gap-4 md:grid-cols-2">
                    <div class="card-shell p-5 space-y-2" x-show="order?.orderType === 'DELIVERY'" x-cloak>
                        <p class="section-label">Delivery partner</p>
                        <p class="text-lg font-semibold text-gray-900" x-text="driverNameLabel()"></p>
                        <p class="text-sm text-gray-500">
                            Contact:
                            <span class="font-medium text-gray-900" x-text="driverPhoneLabel()"></span>
                        </p>
                        <p class="text-sm text-gray-500">
                            Status:
                            <span class="font-medium text-gray-900" x-text="deliveryStatusLabel()"></span>
                        </p>
                        <p class="text-sm text-gray-500" x-show="order?.deliveryEstimatedArrivalTime">
                            ETA: <span class="font-medium text-gray-900" x-text="formatDateTime(order.deliveryEstimatedArrivalTime)"></span>
                        </p>
                        <p class="text-sm text-gray-500" x-show="order?.deliveryActualDeliveryTime">
                            Delivered: <span class="font-medium text-gray-900" x-text="formatDateTime(order.deliveryActualDeliveryTime)"></span>
                        </p>
                    </div>
                    <div class="card-shell p-5 space-y-2">
                        <p class="section-label">Order details</p>
                        <p class="text-sm text-gray-500">Special instructions</p>
                        <p class="text-base text-gray-900" x-text="order?.specialInstructions || 'No additional instructions'"></p>
                        <p class="text-sm text-gray-500" x-show="order?.deliveryAddress">Address</p>
                        <p class="text-base text-gray-900" x-show="order?.deliveryAddress" x-text="order.deliveryAddress"></p>
                    </div>
                </div>

                <!-- Delivery Map -->
                <div class="card-shell p-5" x-show="order?.orderType === 'DELIVERY' && hasDriverLocation()" x-cloak>
                    <div class="mb-3">
                        <p class="section-label">Driver Location</p>
                        <p class="text-sm text-gray-500 mt-1">Track your driver in real-time</p>
                    </div>
                    <div id="deliveryMap"></div>
                </div>

                <div class="card-shell p-6" x-show="orderItemsList().length" x-cloak>
                    <h2 class="text-lg font-semibold text-gray-900 mb-4">Order Items</h2>
                    <div class="space-y-3">
                        <template x-for="item in orderItemsList()" :key="item.id || item.productId || item.productName">
                            <div class="flex items-center justify-between py-3 border-b border-gray-100 last:border-0">
                                <div class="flex items-center gap-3">
                                    <img :src="item.productImageUrl || placeholderImage"
                                         :alt="item.productName"
                                         class="w-12 h-12 rounded-xl object-cover"
                                         @error.once="$event.target.src = placeholderImage" />
                                    <div>
                                        <p class="font-medium text-gray-900" x-text="item.productName"></p>
                                        <p class="text-sm text-gray-500">
                                            Qty <span x-text="item.quantity"></span>
                                            •
                                            <span x-text="formatCurrency(item.unitPrice)"></span>
                                        </p>
                                    </div>
                                </div>
                                <div class="text-right">
                                    <p class="font-semibold text-gray-900" x-text="formatCurrency(item.totalPrice)"></p>
                                </div>
                            </div>
                        </template>
                    </div>
                </div>

                <div class="grid gap-4 md:grid-cols-2">
                    <div class="card-shell p-5 space-y-2">
                        <p class="section-label">Payment summary</p>
                        <p class="text-sm text-gray-600">
                            Method:
                            <span class="font-medium" x-text="paymentMethodLabel()"></span>
                        </p>
                        <p class="text-sm text-gray-600 flex items-center gap-2">
                            Status:
                            <span class="payment-badge" :class="paymentStatusClass()" x-text="paymentStatusLabel()"></span>
                        </p>
                        <p class="text-sm text-gray-600" x-show="order?.paymentPaidAt">
                            Paid on:
                            <span class="font-medium" x-text="formatDateTime(order.paymentPaidAt)"></span>
                        </p>
                        <p class="text-sm text-gray-600" x-show="order?.paymentTransactionId">
                            Transaction ID:
                            <span class="font-medium" x-text="order.paymentTransactionId"></span>
                        </p>
                    </div>
                    <div class="card-shell p-5 space-y-2" x-show="order?.orderType === 'PICKUP'" x-cloak>
                        <p class="section-label">Pickup information</p>
                        <p class="text-sm text-gray-600">
                            Status:
                            <span class="font-medium" x-text="pickupStatusLabel()"></span>
                        </p>
                        <p class="text-sm text-gray-600">
                            Ready at:
                            <span class="font-medium" x-text="pickupReadyLabel()"></span>
                        </p>
                        <p class="text-sm text-gray-600">
                            Pickup window:
                            <span class="font-medium" x-text="pickupWindowLabel()"></span>
                        </p>
                        <p class="text-sm text-gray-600" x-show="order?.pickupCode">
                            Pickup code:
                            <span class="font-mono text-base" x-text="pickupCodeLabel()"></span>
                        </p>
                        <p class="text-sm text-gray-600">
                            Instructions:
                            <span class="font-medium" x-text="pickupInstructionsLabel()"></span>
                        </p>
                    </div>
                    <div class="card-shell p-5 space-y-2">
                        <p class="section-label">Need to change?</p>
                        <p class="text-sm text-gray-600">We can cancel your order until the restaurant confirms it.</p>
                        <div class="flex flex-wrap gap-3">
                            <button onclick="window.location.href='/orders'"
                                    class="flex-1 rounded-xl border border-gray-200 bg-white px-4 py-3 text-sm font-medium text-gray-700 hover:bg-gray-50">
                                Back to orders
                            </button>
                            <form class="flex-1"
                                  th:if="${order.status == 'PENDING' or order.status == 'CONFIRMED'}"
                                  th:action="@{/orders/{orderId}/cancel(orderId=${order.id})}" method="post"
                                  onsubmit="return confirm('Are you sure you want to cancel this order?');"
                                  x-show="canCancel()" x-cloak>
                                <button type="submit"
                                        class="w-full rounded-xl bg-red-600 px-4 py-3 text-sm font-semibold text-white hover:bg-red-700">
                                    Cancel order
                                </button>
                            </form>
                        </div>
                    </div>
                </div>
            </div>
        </template>
    </main>


    <main class="max-w-7xl mx-auto px-4 sm:px-6 py-8" th:unless="${order}">
        <div class="max-w-2xl mx-auto mb-6" th:if="${errorMessage}">
            <div class="rounded-lg border border-red-200 bg-red-50 px-4 py-3 text-red-700" th:text="${errorMessage}"></div>
        </div>
        <div class="text-center py-20">
            <div class="text-gray-400 mb-4">
                <svg class="w-24 h-24 mx-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.172 16.172a4 4 0 015.656 0M9 10h.01M15 10h.01M21 12a9 9 011-18 0 9 9 0 0118 0z"></path>
                </svg>
            </div>
            <h3 class="text-xl font-semibold text-gray-600 mb-2">Order Not Found</h3>
            <p class="text-gray-500 mb-6"
               th:text="${errorMessage != null ? errorMessage : 'The order you\'re looking for doesn\'t exist or has been removed.'}">
                The order you're looking for doesn't exist or has been removed.
            </p>
            <button onclick="window.location.href='/orders'" class="bg-gray-900 text-white px-6 py-3 rounded-md font-medium hover:bg-gray-800 transition-colors">
                Back to Orders
            </button>
        </div>
    </main>

    <th:block th:replace="~{fragments/layout :: footer}"></th:block>
    <th:block th:replace="~{fragments/layout :: api-config}"></th:block>
    <th:block th:replace="~{fragments/layout :: auth-utils}"></th:block>

    <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>
    <script th:inline="javascript">
        window.INITIAL_ORDER = /*[[${order}]]*/ null;
    </script>
    <script>
        const ORDER_STATUS_CLASS_MAP = {
            'PENDING': 'status-PENDING',
            'CONFIRMED': 'status-CONFIRMED',
            'PREPARING': 'status-PREPARING',
            'READY_FOR_PICKUP': 'status-READY_FOR_PICKUP',
            'READY_FOR_DELIVERY': 'status-READY_FOR_DELIVERY',
            'OUT_FOR_DELIVERY': 'status-OUT_FOR_DELIVERY',
            'COMPLETED': 'status-COMPLETED',
            'CANCELLED': 'status-CANCELLED',
            'DELIVERED': 'status-DELIVERED'
        };

        const PAYMENT_STATUS_CLASS_MAP = {
            'PENDING': 'payment-PENDING',
            'AWAITING_SESSION': 'payment-AWAITING_SESSION',
            'AWAITING_WEBHOOK': 'payment-AWAITING_WEBHOOK',
            'CASH_PENDING': 'payment-CASH_PENDING',
            'PROCESSING': 'payment-PROCESSING',
            'COMPLETED': 'payment-COMPLETED',
            'FAILED': 'payment-FAILED',
            'CANCELLED': 'payment-CANCELLED',
            'REFUNDED': 'payment-REFUNDED'
        };

        const TRACKING_STEPS = {
            DELIVERY: [
                { code: 'PENDING', label: 'Pending Confirmation', description: 'We received your order.' },
                { code: 'CONFIRMED', label: 'Confirmed', description: 'Restaurant confirmed the order.' },
                { code: 'PREPARING', label: 'Preparing Order', description: 'Chef is preparing your meal.' },
                { code: 'READY_FOR_DELIVERY', label: 'Ready for Delivery', description: 'Packed and waiting for a driver.' },
                { code: 'OUT_FOR_DELIVERY', label: 'Out for Delivery', description: 'Rider is on the way.' },
                { code: 'COMPLETED', label: 'Completed', description: 'Delivered. Enjoy!' }
            ],
            PICKUP: [
                { code: 'PENDING', label: 'Pending Confirmation', description: 'We received your order.' },
                { code: 'CONFIRMED', label: 'Confirmed', description: 'Restaurant confirmed the order.' },
                { code: 'PREPARING', label: 'Preparing Order', description: 'Chef is preparing your meal.' },
                { code: 'READY_FOR_PICKUP', label: 'Ready for Pickup', description: 'Show your code at the counter.' },
                { code: 'COMPLETED', label: 'Picked Up', description: 'Enjoy your meal!' }
            ]
        };

        function orderDetailsPage() {
            return {
                order: null,
                ready: false,
                runtimeError: '',
                stompClient: null,
                pollTimerId: null,
                placeholderImage: '/images/placeholder-food.jpg',
                trackingStepsByType: TRACKING_STEPS,
                deliveryMap: null,
                driverMarker: null,
                destinationMarker: null,
                routeLine: null,

                init() {
                    this.order = this.prepareOrder(window.INITIAL_ORDER || null);
                    this.ready = true;
                    if (this.order?.id) {
                        this.connectWebsocket();
                        this.startPolling();
                        window.addEventListener('beforeunload', () => this.teardown());
                        // Initialize map after a short delay to ensure DOM is ready
                        setTimeout(() => this.initializeMap(), 500);
                    }
                },

                prepareOrder(order) {
                    if (!order) {
                        return null;
                    }
                    const normalized = { ...order };
                    normalized.orderItems = Array.isArray(order.orderItems) ? order.orderItems : [];
                    if (!normalized.paymentMethod && normalized.paymentStatus === 'CASH_PENDING') {
                        normalized.paymentMethod = 'CASH_ON_DELIVERY';
                    }
                    return normalized;
                },

                connectWebsocket() {
                    if (!this.order?.id || typeof SockJS === 'undefined' || typeof Stomp === 'undefined') {
                        return;
                    }
                    const socket = new SockJS('/ws');
                    this.stompClient = Stomp.over(socket);
                    this.stompClient.reconnect_delay = 5000;
                    this.stompClient.connect({}, () => {
                        const orderId = this.order.id;
                        this.stompClient.subscribe(`/topic/orders/${orderId}`, message => {
                            try {
                                const payload = JSON.parse(message.body);
                                this.applyOrderUpdate(payload);
                            } catch (error) {
                                console.error('Failed to parse order update', error);
                            }
                        });
                        const handleStatusPayload = message => {
                            try {
                                const payload = JSON.parse(message.body);
                                this.applyOrderStatusPayload(orderId, payload);
                            } catch (error) {
                                console.error('Failed to parse order status', error);
                            }
                        };
                        this.stompClient.subscribe(`/topic/orders/${orderId}/status`, handleStatusPayload);
                        this.stompClient.subscribe(`/topic/orders/${orderId}/notifications`, handleStatusPayload);
                    }, error => {
                        console.warn('Unable to connect to order updates', error);
                    });
                },

                startPolling() {
                    if (this.pollTimerId) {
                        clearInterval(this.pollTimerId);
                    }
                    this.pollTimerId = window.setInterval(() => this.refreshOrder(), 30000);
                },

                async refreshOrder() {
                    if (!this.order?.id || !window.API_BASE_URL) {
                        return;
                    }
                    const token = localStorage.getItem('token');
                    if (!token) {
                        this.runtimeError = 'Please login to view this order.';
                        return;
                    }
                    try {
                        const response = await fetch(`${API_BASE_URL}/orders/${this.order.id}`, {
                            headers: {
                                'Authorization': `Bearer ${token}`
                            }
                        });
                        if (response.status === 401) {
                            window.location.href = LOGIN_PAGE_URL;
                            return;
                        }
                        const payload = await response.json();
                        if (!payload.success || !payload.data) {
                            throw new Error(payload.message || 'Unable to load this order.');
                        }
                        this.applyOrderUpdate(payload.data);
                        this.runtimeError = '';
                    } catch (error) {
                        console.error('Failed to refresh order', error);
                        this.runtimeError = error.message || 'Unable to refresh this order right now.';
                    }
                },

                applyOrderUpdate(update) {
                    if (!update) {
                        return;
                    }
                    this.order = this.prepareOrder({ ...(this.order || {}), ...update });
                    
                    // Update map if driver location changed
                    if (update.deliveryLatitude && update.deliveryLongitude) {
                        this.updateDriverLocation(update.deliveryLatitude, update.deliveryLongitude);
                    }
                },

                applyOrderStatusPayload(orderId, payload) {
                    if (!payload) {
                        return;
                    }
                    const update = { id: orderId };
                    if (payload.status) {
                        update.status = payload.status;
                    }
                    if (payload.estimatedDeliveryTime) {
                        update.estimatedDeliveryTime = payload.estimatedDeliveryTime;
                    }
                    Object.assign(update, this.extractMetadataUpdates(payload.metadata));
                    this.applyOrderUpdate(update);
                },

                extractMetadataUpdates(metadata) {
                    if (!metadata || typeof metadata !== 'object') {
                        return {};
                    }
                    const updates = {};
                    const driverName = metadata.deliveryDriverName || metadata.driverName;
                    const driverPhone = metadata.deliveryDriverPhone || metadata.driverPhone;
                    const driverStatus = metadata.deliveryStatus || metadata.driverStatus;
                    const eta = metadata.deliveryEstimatedArrivalTime || metadata.deliveryEta || metadata.estimatedArrivalTime;
                    const actualDelivered = metadata.deliveryActualDeliveryTime || metadata.deliveredAt;
                    if (driverName) {
                        updates.deliveryDriverName = driverName;
                    }
                    if (driverPhone) {
                        updates.deliveryDriverPhone = driverPhone;
                    }
                    if (driverStatus) {
                        updates.deliveryStatus = driverStatus;
                    }
                    if (eta) {
                        updates.deliveryEstimatedArrivalTime = eta;
                    }
                    if (actualDelivered) {
                        updates.deliveryActualDeliveryTime = actualDelivered;
                    }
                    if (metadata.paymentStatus) {
                        updates.paymentStatus = metadata.paymentStatus;
                    }
                    if (metadata.paymentMethod) {
                        updates.paymentMethod = metadata.paymentMethod;
                    }
                    if (metadata.pickupStatus) {
                        updates.pickupStatus = metadata.pickupStatus;
                    }
                    if (metadata.pickupCode) {
                        updates.pickupCode = metadata.pickupCode;
                    }
                    if (metadata.pickupWindowStart) {
                        updates.pickupWindowStart = metadata.pickupWindowStart;
                    }
                    if (metadata.pickupWindowEnd) {
                        updates.pickupWindowEnd = metadata.pickupWindowEnd;
                    }
                    if (metadata.pickupReadyAt) {
                        updates.pickupReadyAt = metadata.pickupReadyAt;
                    }
                    if (metadata.pickupPickedUpAt) {
                        updates.pickupPickedUpAt = metadata.pickupPickedUpAt;
                    }
                    if (metadata.pickupInstructions) {
                        updates.pickupInstructions = metadata.pickupInstructions;
                    }
                    if (metadata.status) {
                        updates.status = metadata.status;
                    }
                    if (metadata.orderStatus) {
                        updates.status = metadata.orderStatus;
                    }
                    if (metadata.deliveryLatitude || metadata.latitude) {
                        updates.deliveryLatitude = metadata.deliveryLatitude || metadata.latitude;
                    }
                    if (metadata.deliveryLongitude || metadata.longitude) {
                        updates.deliveryLongitude = metadata.deliveryLongitude || metadata.longitude;
                    }
                    return updates;
                },

                teardown() {
                    if (this.pollTimerId) {
                        clearInterval(this.pollTimerId);
                        this.pollTimerId = null;
                    }
                    if (this.stompClient) {
                        try {
                            this.stompClient.disconnect();
                        } catch (error) {
                            console.warn('Error disconnecting socket', error);
                        }
                        this.stompClient = null;
                    }
                },

                orderItemsList() {
                    return Array.isArray(this.order?.orderItems) ? this.order.orderItems : [];
                },

                orderTitle() {
                    return this.order ? `Order #${this.order.id}` : '';
                },

                placedOnLabel() {
                    return this.order?.createdAt ? `Placed on ${this.formatDateTime(this.order.createdAt)}` : '';
                },

                contactLabel() {
                    if (!this.order) {
                        return '';
                    }
                    const name = this.order.customerName || 'Customer';
                    return this.order.phoneNumber ? `${name} • ${this.order.phoneNumber}` : name;
                },

                statusBadgeClass(status) {
                    return ORDER_STATUS_CLASS_MAP[status || this.order?.status] || 'status-PENDING';
                },

                formatCurrency(value) {
                    const number = Number(value);
                    if (!Number.isNaN(number) && Number.isFinite(number)) {
                        return `${number.toLocaleString('en-US')}៛`;
                    }
                    return value ? `${value}៛` : '0៛';
                },

                formatDateTime(value) {
                    if (!value) {
                        return '';
                    }
                    try {
                        const date = new Date(value);
                        if (!Number.isNaN(date.getTime())) {
                            return date.toLocaleString('en-US', {
                                year: 'numeric',
                                month: 'short',
                                day: 'numeric',
                                hour: '2-digit',
                                minute: '2-digit'
                            });
                        }
                    } catch (error) {
                        console.warn('Unable to format date', value, error);
                    }
                    return value;
                },

                formatEnum(value) {
                    if (!value) {
                        return 'N/A';
                    }
                    return value
                        .toString()
                        .split('_')
                        .map(part => part.charAt(0) + part.slice(1).toLowerCase())
                        .join(' ');
                },

                currentTrackingSteps() {
                    const type = this.order?.orderType;
                    if (type && this.trackingStepsByType[type]) {
                        return this.trackingStepsByType[type];
                    }
                    return this.trackingStepsByType.DELIVERY;
                },

                trackingStepCount() {
                    const steps = this.currentTrackingSteps();
                    return Array.isArray(steps) ? steps.length : 0;
                },

                trackingIndex() {
                    if (!this.order) {
                        return -1;
                    }
                    const steps = this.currentTrackingSteps();
                    return steps.findIndex(step => step.code === this.order.status);
                },

                trackingHeroDescription() {
                    if (!this.order) {
                        return '';
                    }
                    if (this.order.status === 'CANCELLED') {
                        return 'This order was cancelled before completion.';
                    }
                    const steps = this.currentTrackingSteps();
                    const index = this.trackingIndex();
                    if (index === -1 || steps.length === 0) {
                        return 'See what step comes next so you always know what to expect.';
                    }
                    if (index >= steps.length - 1) {
                        return 'Your order is complete. Enjoy every bite!';
                    }
                    const current = steps[index];
                    const next = steps[index + 1];
                    return `${current.label} stage in progress. Next: ${next.label}.`;
                },

                trackingProgressLabel() {
                    if (!this.order) {
                        return '';
                    }
                    if (this.order.status === 'CANCELLED') {
                        return 'Order Cancelled';
                    }
                    const index = this.trackingIndex();
                    const stepCount = this.trackingStepCount();
                    if (index === -1 || stepCount === 0) {
                        return 'Awaiting first update';
                    }
                    return `Step ${Math.min(index + 1, stepCount)} of ${stepCount}`;
                },

                trackingProgressPercent() {
                    if (!this.order || this.order.status === 'CANCELLED') {
                        return 0;
                    }
                    const index = this.trackingIndex();
                    const stepCount = this.trackingStepCount();
                    if (index === -1 || stepCount === 0) {
                        return 0;
                    }
                    return Math.min(100, Math.max(0, ((index + 1) / stepCount) * 100));
                },

                trackingRemainingLabel() {
                    if (!this.order) {
                        return '';
                    }
                    if (this.order.status === 'CANCELLED') {
                        return 'This order was cancelled before completion.';
                    }
                    const index = this.trackingIndex();
                    const steps = this.currentTrackingSteps();
                    if (index === -1 || steps.length === 0) {
                        return 'We will show the remaining steps once your order is confirmed.';
                    }
                    if (index >= steps.length - 1) {
                        return 'All steps are complete. Enjoy your meal!';
                    }
                    const remaining = steps.slice(index + 1).map(step => step.label);
                    return `Still to come: ${remaining.join(' → ')}`;
                },

                trackingStepClass(stepCode) {
                    if (!this.order) {
                        return 'tracking-step-upcoming';
                    }
                    if (this.order.status === 'CANCELLED') {
                        return stepCode === 'PENDING' ? 'tracking-step-cancelled' : 'tracking-step-upcoming';
                    }
                    const activeIndex = this.trackingIndex();
                    const steps = this.currentTrackingSteps();
                    const stepIndex = steps.findIndex(step => step.code === stepCode);
                    if (activeIndex === -1 || stepIndex === -1) {
                        return 'tracking-step-upcoming';
                    }
                    if (stepIndex < activeIndex) {
                        return 'tracking-step-completed';
                    }
                    if (stepIndex === activeIndex) {
                        return 'tracking-step-active';
                    }
                    return 'tracking-step-upcoming';
                },

                paymentMethodLabel() {
                    const method = this.order?.paymentMethod || (this.order?.paymentStatus === 'CASH_PENDING' ? 'CASH_ON_DELIVERY' : null);
                    return method ? this.formatEnum(method) : 'N/A';
                },

                paymentStatusLabel() {
                    return this.order?.paymentStatus ? this.formatEnum(this.order.paymentStatus) : 'N/A';
                },

                paymentStatusClass() {
                    return this.order?.paymentStatus ? (PAYMENT_STATUS_CLASS_MAP[this.order.paymentStatus] || '') : '';
                },

                driverNameLabel() {
                    return this.order?.deliveryDriverName || 'Driver assigned soon';
                },

                driverPhoneLabel() {
                    return this.order?.deliveryDriverPhone || 'Not available yet';
                },

                deliveryStatusLabel() {
                    return this.order?.deliveryStatus ? this.formatEnum(this.order.deliveryStatus) : 'Pending';
                },

                pickupStatusLabel() {
                    const status = this.order?.pickupStatus;
                    return status ? this.formatEnum(status) : 'Awaiting confirmation';
                },

                pickupReadyLabel() {
                    return this.order?.pickupReadyAt ? this.formatDateTime(this.order.pickupReadyAt) : 'Not ready yet';
                },

                pickupWindowLabel() {
                    const start = this.order?.pickupWindowStart ? this.formatDateTime(this.order.pickupWindowStart) : null;
                    const end = this.order?.pickupWindowEnd ? this.formatDateTime(this.order.pickupWindowEnd) : null;
                    if (start && end) {
                        return `${start} → ${end}`;
                    }
                    return start || end || 'Pending';
                },

                pickupCodeLabel() {
                    return this.order?.pickupCode || 'Code will be generated once ready';
                },

                pickupInstructionsLabel() {
                    return this.order?.pickupInstructions || 'Show your confirmation at the pickup counter.';
                },

                canCancel() {
                    const status = this.order?.status;
                    return status === 'PENDING' || status === 'CONFIRMED';
                },

                hasDriverLocation() {
                    return this.order?.deliveryLatitude && this.order?.deliveryLongitude;
                },

                initializeMap() {
                    if (!this.hasDriverLocation() || this.deliveryMap) {
                        return;
                    }

                    const driverLat = this.order.deliveryLatitude;
                    const driverLng = this.order.deliveryLongitude;

                    // Try to parse destination coordinates from delivery address
                    // For now, we'll center on driver location, but you can add logic to parse address
                    const centerLat = driverLat;
                    const centerLng = driverLng;

                    // Initialize map centered between driver and destination
                    this.deliveryMap = L.map('deliveryMap').setView([centerLat, centerLng], 13);

                    // Add OpenStreetMap tile layer
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                        maxZoom: 19
                    }).addTo(this.deliveryMap);

                    // Create custom driver icon (blue car)
                    const driverIcon = L.divIcon({
                        className: 'custom-driver-marker',
                        html: '<div style="background-color: #3b82f6; width: 36px; height: 36px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 10px rgba(59, 130, 246, 0.5); display: flex; align-items: center; justify-content: center; animation: pulse 2s infinite;"><svg style="width: 18px; height: 18px; fill: white;" viewBox="0 0 24 24"><path d="M18.92 6.01C18.72 5.42 18.16 5 17.5 5h-11c-.66 0-1.21.42-1.42 1.01L3 12v8c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-1h12v1c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-8l-2.08-5.99zM6.5 16c-.83 0-1.5-.67-1.5-1.5S5.67 13 6.5 13s1.5.67 1.5 1.5S7.33 16 6.5 16zm11 0c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zM5 11l1.5-4.5h11L19 11H5z"/></svg></div><style>@keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } }</style>',
                        iconSize: [36, 36],
                        iconAnchor: [18, 18]
                    });

                    // Create custom destination icon (red pin)
                    const destinationIcon = L.divIcon({
                        className: 'custom-destination-marker',
                        html: '<div style="background-color: #ef4444; width: 32px; height: 32px; border-radius: 50% 50% 50% 0; transform: rotate(-45deg); border: 3px solid white; box-shadow: 0 2px 8px rgba(239, 68, 68, 0.4); display: flex; align-items: center; justify-content: center;"><svg style="width: 16px; height: 16px; fill: white; transform: rotate(45deg);" viewBox="0 0 24 24"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg></div>',
                        iconSize: [32, 32],
                        iconAnchor: [8, 32]
                    });

                    // Add driver marker
                    this.driverMarker = L.marker([driverLat, driverLng], { icon: driverIcon })
                        .addTo(this.deliveryMap)
                        .bindPopup('<b>Driver Location</b><br/>Your order is on the way!<br/><small>' + (this.order.deliveryDriverName || 'Driver') + '</small>');

                    // Add destination marker if we have delivery address coordinates
                    // You can enhance this by geocoding the delivery address
                    // For demo purposes, we'll add a marker slightly offset from driver
                    if (this.order.deliveryAddress) {
                        // This is a placeholder - in production, you'd geocode the address
                        // For now, show it as a popup on the driver marker
                        const destLat = driverLat + 0.01; // Offset for demo
                        const destLng = driverLng + 0.01;
                        
                        this.destinationMarker = L.marker([destLat, destLng], { icon: destinationIcon })
                            .addTo(this.deliveryMap)
                            .bindPopup('<b>Delivery Destination</b><br/>' + this.order.deliveryAddress);

                        // Draw a line between driver and destination
                        this.routeLine = L.polyline([
                            [driverLat, driverLng],
                            [destLat, destLng]
                        ], {
                            color: '#3b82f6',
                            weight: 3,
                            opacity: 0.6,
                            dashArray: '10, 10'
                        }).addTo(this.deliveryMap);

                        // Fit bounds to show both markers
                        const bounds = L.latLngBounds([[driverLat, driverLng], [destLat, destLng]]);
                        this.deliveryMap.fitBounds(bounds, { padding: [50, 50] });
                    }
                },

                updateDriverLocation(lat, lng) {
                    if (!this.deliveryMap) {
                        this.order.deliveryLatitude = lat;
                        this.order.deliveryLongitude = lng;
                        this.initializeMap();
                        return;
                    }

                    // Update marker position
                    if (this.driverMarker) {
                        this.driverMarker.setLatLng([lat, lng]);
                    }

                    // Update route line if destination marker exists
                    if (this.routeLine && this.destinationMarker) {
                        const destLatLng = this.destinationMarker.getLatLng();
                        this.routeLine.setLatLngs([
                            [lat, lng],
                            [destLatLng.lat, destLatLng.lng]
                        ]);

                        // Fit bounds to show both markers
                        const bounds = L.latLngBounds([[lat, lng], [destLatLng.lat, destLatLng.lng]]);
                        this.deliveryMap.fitBounds(bounds, { padding: [50, 50] });
                    } else {
                        // Pan map to new driver location
                        this.deliveryMap.panTo([lat, lng]);
                    }
                },

                teardown() {
                    if (this.stompClient) {
                        this.stompClient.disconnect();
                    }
                    if (this.pollTimerId) {
                        clearInterval(this.pollTimerId);
                    }
                    if (this.deliveryMap) {
                        this.deliveryMap.remove();
                        this.deliveryMap = null;
                        this.driverMarker = null;
                        this.destinationMarker = null;
                        this.routeLine = null;
                    }
                }
            };
        }
    </script>

</body>
</html>
